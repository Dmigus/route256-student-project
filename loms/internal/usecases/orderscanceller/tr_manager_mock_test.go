// Code generated by http://github.com/gojuno/minimock (dev). DO NOT EDIT.

package orderscanceller

//go:generate minimock -i route256.ozon.ru/project/loms/internal/usecases/orderscanceller.trManager -o tr_manager_mock_test.go -n TrManagerMock -p orderscanceller

import (
	"context"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
)

// TrManagerMock implements trManager
type TrManagerMock struct {
	t          minimock.Tester
	finishOnce sync.Once

	funcWithinTransaction          func(ctx context.Context, f1 func(ctx context.Context, orders OrderRepo, stocks StockRepo) error) (err error)
	inspectFuncWithinTransaction   func(ctx context.Context, f1 func(ctx context.Context, orders OrderRepo, stocks StockRepo) error)
	afterWithinTransactionCounter  uint64
	beforeWithinTransactionCounter uint64
	WithinTransactionMock          mTrManagerMockWithinTransaction
}

// NewTrManagerMock returns a mock for trManager
func NewTrManagerMock(t minimock.Tester) *TrManagerMock {
	m := &TrManagerMock{t: t}

	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.WithinTransactionMock = mTrManagerMockWithinTransaction{mock: m}
	m.WithinTransactionMock.callArgs = []*TrManagerMockWithinTransactionParams{}

	t.Cleanup(m.MinimockFinish)

	return m
}

type mTrManagerMockWithinTransaction struct {
	mock               *TrManagerMock
	defaultExpectation *TrManagerMockWithinTransactionExpectation
	expectations       []*TrManagerMockWithinTransactionExpectation

	callArgs []*TrManagerMockWithinTransactionParams
	mutex    sync.RWMutex
}

// TrManagerMockWithinTransactionExpectation specifies expectation struct of the trManager.WithinTransaction
type TrManagerMockWithinTransactionExpectation struct {
	mock    *TrManagerMock
	params  *TrManagerMockWithinTransactionParams
	results *TrManagerMockWithinTransactionResults
	Counter uint64
}

// TrManagerMockWithinTransactionParams contains parameters of the trManager.WithinTransaction
type TrManagerMockWithinTransactionParams struct {
	ctx context.Context
	f1  func(ctx context.Context, orders OrderRepo, stocks StockRepo) error
}

// TrManagerMockWithinTransactionResults contains results of the trManager.WithinTransaction
type TrManagerMockWithinTransactionResults struct {
	err error
}

// Expect sets up expected params for trManager.WithinTransaction
func (mmWithinTransaction *mTrManagerMockWithinTransaction) Expect(ctx context.Context, f1 func(ctx context.Context, orders OrderRepo, stocks StockRepo) error) *mTrManagerMockWithinTransaction {
	if mmWithinTransaction.mock.funcWithinTransaction != nil {
		mmWithinTransaction.mock.t.Fatalf("TrManagerMock.WithinTransaction mock is already set by Set")
	}

	if mmWithinTransaction.defaultExpectation == nil {
		mmWithinTransaction.defaultExpectation = &TrManagerMockWithinTransactionExpectation{}
	}

	mmWithinTransaction.defaultExpectation.params = &TrManagerMockWithinTransactionParams{ctx, f1}
	for _, e := range mmWithinTransaction.expectations {
		if minimock.Equal(e.params, mmWithinTransaction.defaultExpectation.params) {
			mmWithinTransaction.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmWithinTransaction.defaultExpectation.params)
		}
	}

	return mmWithinTransaction
}

// Inspect accepts an inspector function that has same arguments as the trManager.WithinTransaction
func (mmWithinTransaction *mTrManagerMockWithinTransaction) Inspect(f func(ctx context.Context, f1 func(ctx context.Context, orders OrderRepo, stocks StockRepo) error)) *mTrManagerMockWithinTransaction {
	if mmWithinTransaction.mock.inspectFuncWithinTransaction != nil {
		mmWithinTransaction.mock.t.Fatalf("Inspect function is already set for TrManagerMock.WithinTransaction")
	}

	mmWithinTransaction.mock.inspectFuncWithinTransaction = f

	return mmWithinTransaction
}

// Return sets up results that will be returned by trManager.WithinTransaction
func (mmWithinTransaction *mTrManagerMockWithinTransaction) Return(err error) *TrManagerMock {
	if mmWithinTransaction.mock.funcWithinTransaction != nil {
		mmWithinTransaction.mock.t.Fatalf("TrManagerMock.WithinTransaction mock is already set by Set")
	}

	if mmWithinTransaction.defaultExpectation == nil {
		mmWithinTransaction.defaultExpectation = &TrManagerMockWithinTransactionExpectation{mock: mmWithinTransaction.mock}
	}
	mmWithinTransaction.defaultExpectation.results = &TrManagerMockWithinTransactionResults{err}
	return mmWithinTransaction.mock
}

// Set uses given function f to mock the trManager.WithinTransaction method
func (mmWithinTransaction *mTrManagerMockWithinTransaction) Set(f func(ctx context.Context, f1 func(ctx context.Context, orders OrderRepo, stocks StockRepo) error) (err error)) *TrManagerMock {
	if mmWithinTransaction.defaultExpectation != nil {
		mmWithinTransaction.mock.t.Fatalf("Default expectation is already set for the trManager.WithinTransaction method")
	}

	if len(mmWithinTransaction.expectations) > 0 {
		mmWithinTransaction.mock.t.Fatalf("Some expectations are already set for the trManager.WithinTransaction method")
	}

	mmWithinTransaction.mock.funcWithinTransaction = f
	return mmWithinTransaction.mock
}

// When sets expectation for the trManager.WithinTransaction which will trigger the result defined by the following
// Then helper
func (mmWithinTransaction *mTrManagerMockWithinTransaction) When(ctx context.Context, f1 func(ctx context.Context, orders OrderRepo, stocks StockRepo) error) *TrManagerMockWithinTransactionExpectation {
	if mmWithinTransaction.mock.funcWithinTransaction != nil {
		mmWithinTransaction.mock.t.Fatalf("TrManagerMock.WithinTransaction mock is already set by Set")
	}

	expectation := &TrManagerMockWithinTransactionExpectation{
		mock:   mmWithinTransaction.mock,
		params: &TrManagerMockWithinTransactionParams{ctx, f1},
	}
	mmWithinTransaction.expectations = append(mmWithinTransaction.expectations, expectation)
	return expectation
}

// Then sets up trManager.WithinTransaction return parameters for the expectation previously defined by the When method
func (e *TrManagerMockWithinTransactionExpectation) Then(err error) *TrManagerMock {
	e.results = &TrManagerMockWithinTransactionResults{err}
	return e.mock
}

// WithinTransaction implements trManager
func (mmWithinTransaction *TrManagerMock) WithinTransaction(ctx context.Context, f1 func(ctx context.Context, orders OrderRepo, stocks StockRepo) error) (err error) {
	mm_atomic.AddUint64(&mmWithinTransaction.beforeWithinTransactionCounter, 1)
	defer mm_atomic.AddUint64(&mmWithinTransaction.afterWithinTransactionCounter, 1)

	if mmWithinTransaction.inspectFuncWithinTransaction != nil {
		mmWithinTransaction.inspectFuncWithinTransaction(ctx, f1)
	}

	mm_params := TrManagerMockWithinTransactionParams{ctx, f1}

	// Record call args
	mmWithinTransaction.WithinTransactionMock.mutex.Lock()
	mmWithinTransaction.WithinTransactionMock.callArgs = append(mmWithinTransaction.WithinTransactionMock.callArgs, &mm_params)
	mmWithinTransaction.WithinTransactionMock.mutex.Unlock()

	for _, e := range mmWithinTransaction.WithinTransactionMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmWithinTransaction.WithinTransactionMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmWithinTransaction.WithinTransactionMock.defaultExpectation.Counter, 1)
		mm_want := mmWithinTransaction.WithinTransactionMock.defaultExpectation.params
		mm_got := TrManagerMockWithinTransactionParams{ctx, f1}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmWithinTransaction.t.Errorf("TrManagerMock.WithinTransaction got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmWithinTransaction.WithinTransactionMock.defaultExpectation.results
		if mm_results == nil {
			mmWithinTransaction.t.Fatal("No results are set for the TrManagerMock.WithinTransaction")
		}
		return (*mm_results).err
	}
	if mmWithinTransaction.funcWithinTransaction != nil {
		return mmWithinTransaction.funcWithinTransaction(ctx, f1)
	}
	mmWithinTransaction.t.Fatalf("Unexpected call to TrManagerMock.WithinTransaction. %v %v", ctx, f1)
	return
}

// WithinTransactionAfterCounter returns a count of finished TrManagerMock.WithinTransaction invocations
func (mmWithinTransaction *TrManagerMock) WithinTransactionAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmWithinTransaction.afterWithinTransactionCounter)
}

// WithinTransactionBeforeCounter returns a count of TrManagerMock.WithinTransaction invocations
func (mmWithinTransaction *TrManagerMock) WithinTransactionBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmWithinTransaction.beforeWithinTransactionCounter)
}

// Calls returns a list of arguments used in each call to TrManagerMock.WithinTransaction.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmWithinTransaction *mTrManagerMockWithinTransaction) Calls() []*TrManagerMockWithinTransactionParams {
	mmWithinTransaction.mutex.RLock()

	argCopy := make([]*TrManagerMockWithinTransactionParams, len(mmWithinTransaction.callArgs))
	copy(argCopy, mmWithinTransaction.callArgs)

	mmWithinTransaction.mutex.RUnlock()

	return argCopy
}

// MinimockWithinTransactionDone returns true if the count of the WithinTransaction invocations corresponds
// the number of defined expectations
func (m *TrManagerMock) MinimockWithinTransactionDone() bool {
	for _, e := range m.WithinTransactionMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.WithinTransactionMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterWithinTransactionCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcWithinTransaction != nil && mm_atomic.LoadUint64(&m.afterWithinTransactionCounter) < 1 {
		return false
	}
	return true
}

// MinimockWithinTransactionInspect logs each unmet expectation
func (m *TrManagerMock) MinimockWithinTransactionInspect() {
	for _, e := range m.WithinTransactionMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to TrManagerMock.WithinTransaction with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.WithinTransactionMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterWithinTransactionCounter) < 1 {
		if m.WithinTransactionMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to TrManagerMock.WithinTransaction")
		} else {
			m.t.Errorf("Expected call to TrManagerMock.WithinTransaction with params: %#v", *m.WithinTransactionMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcWithinTransaction != nil && mm_atomic.LoadUint64(&m.afterWithinTransactionCounter) < 1 {
		m.t.Error("Expected call to TrManagerMock.WithinTransaction")
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *TrManagerMock) MinimockFinish() {
	m.finishOnce.Do(func() {
		if !m.minimockDone() {
			m.MinimockWithinTransactionInspect()
			m.t.FailNow()
		}
	})
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *TrManagerMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *TrManagerMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockWithinTransactionDone()
}
